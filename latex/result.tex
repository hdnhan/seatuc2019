\subsection{Error evaluation with exact solution}
We study a numerical experiment with the exact solution of heat equation and evaluate the error convergence. Consider a square $[0,1]\times[0,1]$. Find $u(x,y,t)$ satisfy
\begin{equation}
\dfrac{\partial u}{\partial t} - \left(\dfrac{\partial^2 u}{\partial x^2} + \dfrac{\partial^2u}{\partial y^2}\right) = (1+2t)\sin(\pi x) \sin(\pi y)
\end{equation}
with the initial and boundary conditions
$$
u(x,y,0) = 0 \quad \text{and} \quad u|_\Gamma = 0.
$$
The exact solution is
$$
u = \sin(\pi x) \sin(\pi y) t,
$$
The approximate solution at final time is illustrated below.
\begin{figure}[ht]
	\centering
	\includegraphics[width=4cm]{dirac}
\end{figure}
Different cases of mesh size and time step length were studied to show the dependent of error on the mesh smoothness. We also use two different schemes
\begin{itemize}
	\item Backward Euler scheme
	\begin{figure}[ht]
		\centering
		\includegraphics[width=4cm]{BE} \quad
		\includegraphics[width=4cm]{BEt}
	\end{figure}
	\item Crank-Nicolson scheme
	\begin{figure}[ht]
		\centering
		\includegraphics[width=4cm]{CN} \quad
		\includegraphics[width=4cm]{CNt}
	\end{figure}
\end{itemize}

\subsection{A problem of thermal engineering}
We apply the numerical simulations of heat transfer into designing heat sink. Assuming a hot CPU inside a rectangular room fill with air. Let $u=u_{hot}$ inside CPU region and $u=u_{air}$ on air region, respectively $\Omega_{c}$ and $\Omega_{a}$, on the initial time. Our goal is to design a heat sink stick on the CPU to lower its temperature. \\
%\begin{figure}[ht]
%	\centering
%	\begin{tikzpicture}
%		\draw (-1,0) -- (2,0);
%		\draw (2,0) -- (2,3);
%		\draw (2,3) -- (-1,3);
%		\draw (-1,3) -- (-1,0);
%		\draw (0,0) -- (0,1);
%		\draw (0,1) -- (1,1);
%		\draw (1,1) -- (1,0);
%	\end{tikzpicture}
%\end{figure}
The heat sink region, let say $\Omega_{s}$, has thermal conductivity coefficient $\kappa_s$. Similarly let $\kappa_a$ and $\kappa_c$ are respectively the thermal conductivity coefficients inside air and CPU region. Technically, $\kappa_a$ is small compare to $\kappa_c$ and $\kappa_s$ due to nature conduction of air. Furthermore, to provide cooling ability, $\kappa_s>\kappa_c$. Our heat transfer simulations of different heat sink shapes are shown below. The visualization using medit software.\\
\begin{figure}[ht]
	\centering
	\begin{tabular}{c c}
		\includegraphics[width=4cm]{nosinkc} & \includegraphics[width=4cm]{nosinkb}
	\end{tabular}
	\caption{Thermal conduction with no heat sink. $u_{min}=58.4$, $u_{max}=59.8$.}
\end{figure}
\begin{figure}[ht]
	\centering
	\begin{tabular}{c c}
		\includegraphics[width=4cm]{recsinkc} & \includegraphics[width=4cm]{recsinka}
	\end{tabular}
	\caption{Thermal conduction with rectangular shape heat sink. $u_{min}=42.3$, $u_{max}=42.6$.}
\end{figure}
\begin{figure}[ht]
	\centering
	\begin{tabular}{c c}
		\includegraphics[width=4cm]{platec} & \includegraphics[width=4cm]{plateb}
	\end{tabular}
	\caption{Thermal conduction with fin shape heat sink. $u_{min}=32.4$, $u_{max}=32.6$.}
\end{figure}
It is obvious that the fin shape heat sink provide better thermal radiator ability compare to a normal rectangular shape, plus requires less material.
%\subsection{Numerical experiment of an optimal control problem}
%FreeFem++ provide an efficient tool to handle optimal control problem for partial differential equations by using the C++ optimization module IPOPT. To be more accurate, the module support multiple languages in solving optimization problems. The application of IPOPT for solving inverse heat problem is shown below.\\
%To use the IPOPT module we have to add command
%\begin{verbatim}
%load "ff-Ipopt"
%\end{verbatim}
%We need to find the expression of objective function $J$ and its gradient $\nabla J$ respective with the input control function $f$. The optimal $f$ is achieved via IPOPT loop using a conjugate gradient method solver such as Newton-Raphson method.
%\begin{verbatim}
%func real J(real[int] f) {
%Vh3 f3; f3[] = f;
%Vh3 u; u[] = StateProblem(f); 
%Vh3 del; del[] = u[] - w[];
%return 0.5 * int3d(Th3)(del * del) + 0.5 * gamma * int3d(Th3)(f3 * f3);
%}
%\end{verbatim}
%\begin{verbatim}
%func real[int] GradJ(real[int] f) {
%Vh3 p; p[] = AdjointProblem(StateProblem(f));
%Vh3 pq = p * q;
%real[int] res = pq[] + gamma * f;
%return res;
%}
%\end{verbatim}
%Execute the optimization with command
%\begin{verbatim}
%IPOPT(J, GradJ, fh[]);
%\end{verbatim}
%This is an illustrating of the expected control $f$ and its approximation using IPOPT. 

