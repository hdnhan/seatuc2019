load "ff-IpOpt"
load "msh3"
load "medit"


int nn = 40;
int Nx = nn, Ny = nn, Nt = nn;
real T = 1.0;
real hx = 1.0/Nx, hy = 1.0/Ny, ht = T/Nt;

mesh Th2 = square(Nx, Ny);
fespace Vh2(Th2, P1);

mesh3 Th3 = cube(Nx, Ny, Nt);
fespace Vh3(Th3, P1);

macro grad(u) [dx(u), dy(u)]//

// Data
Vh3 ue = exp(z) * sin(pi * x) * sin(pi * y);
Vh3 fe = sin(pi * z) * sin(pi * x) * sin(pi * y);
Vh3 q = x * y + z + 1;
Vh3 g = (1 + 2 * pi ^ 2) * ue - fe * q;
real gamma = 1e-5;

Vh2 u0 = ue(x, y, 0);

Vh3 w = ue;

// State equation:
func real[int] StateProblem(real[int] f){
	Vh3 u3, f3; f3[] = f;
	Vh3 rhs = f3 * q + g;
    Vh2 u, v, fprev, fnext;
    Vh2 uprev = u0;

    for(int ny = 0; ny <= Ny; ny++){
		for(int nx = 0; nx <= Nx; nx++){
			fprev[][ny * (Nx + 1) + nx] = rhs[][ny * (Nx + 1) + nx];
			u3[][ny * (Nx + 1) + nx] = uprev[][ny * (Nx + 1) + nx];
		}
	}

    for(int nt = 1; nt <= Nt; nt++){

		for(int ny = 0; ny <= Ny; ny++){
			for(int nx = 0; nx <= Nx; nx++){
				fnext[][ny * (Nx + 1) + nx] = rhs[][nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx];
			}
		}
	
		solve CrankNicolson(u, v, solver = CG) = 
			  int2d(Th2)(u * v / ht + 0.5 * grad(u)' * grad(v))
			+ int2d(Th2)(-uprev * v / ht + 0.5 * grad(uprev)' * grad(v))
			- int2d(Th2)(0.5 * (fprev + fnext) * v) 
			+ on(1, 2, 3, 4, u = 0);

		for(int ny = 0; ny <= Ny; ny++){
			for(int nx = 0; nx <= Nx; nx++){
				u3[][nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = u[][ny * (Nx + 1) + nx];
			}
		}

		fprev = fnext;
		uprev = u;
	}

	return u3[];
}



// Adjoint equation
func real[int] AdjointProblem(real[int] u){

    Vh3 p3;
    Vh3 rhs; rhs[] = u - w[];

    Vh2 p, v, fprev, fnext;
    Vh2 pprev = 0;
    //Vh2 pprev = ue(x, y, T);

    for(int ny = 0; ny <= Ny; ny++){
		for(int nx = 0; nx <= Nx; nx++){
			fprev[][ny * (Nx + 1) + nx] = rhs[][Nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx];
			p3[][Nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = pprev[][ny * (Nx + 1) + nx];
		}
	}

    for(int nt = 1; nt <= Nt; nt++){

		for(int ny = 0; ny <= Ny; ny++){
			for(int nx = 0; nx <= Nx; nx++){
				fnext[][ny * (Nx + 1) + nx] = rhs[][(Nt - nt) * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx];
			}
		}
	
		solve CrankNicolson(p, v, solver = CG) = 
			  int2d(Th2)(p * v / ht + 0.5 * grad(p)' * grad(v))
			+ int2d(Th2)(-pprev * v / ht + 0.5 * grad(pprev)' * grad(v))
			- int2d(Th2)(0.5 * (fprev + fnext) * v) 
			+ on(1, 2, 3, 4, p = 0);

		for(int ny = 0; ny <= Ny; ny++){
			for(int nx = 0; nx <= Nx; nx++){
				p3[][(Nt - nt) * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = p[][ny * (Nx + 1) + nx];
			}
		}

		fprev = fnext;
		pprev = p;
	}

	return p3[];
}


// Tikhonov functional
func real J(real[int] f) {
    Vh3 f3; f3[] = f;
    Vh3 u; u[] = StateProblem(f); 
    Vh3 del; del[] = u[] - w[];
    return 0.5 * int3d(Th3)(del * del) + 0.5 * gamma * int3d(Th3)(f3 * f3);
}


// Gradient of Tikhonov funtional
func real[int] GradJ(real[int] f) {
    Vh3 p; p[] = AdjointProblem(StateProblem(f));
    Vh3 pq = p * q;
    real[int] res = pq[] + gamma * f;
    return res;
}



Vh3 fh = 0;
//IPOPT(J, GradJ, fh[], tol = 1e-6);
IPOPT(J, GradJ, fh[]);
//savesol("2D_Q_fh.sol", Th, fh);

cout << "J: " << J(fh[]) << endl; 
Vh3 del = fh - fe;

cout << "fe min and max: " << fe[].min << ", " << fe[].max << endl;
cout << "fh min and max: " << fh[].min << ", " << fh[].max << endl;
cout << "(fh-fe) min and max: " << del[].min << ", " << del[].max << endl;
cout << "erorr L2: " << sqrt(int3d(Th3)(del * del)) << endl;


/*
Vh3 haha = (-1 + 2 * pi ^ 2) * ue;
//Vh3 uap; uap[] = StateProblem(fe[]);
Vh3 del; del[] = AdjointProblem(haha[]) - ue[]; //uap - ue;
cout << "(fh-fe) min and max: " << del[].min << ", " << del[].max << endl;
cout << "erorr L2: " << sqrt(int3d(Th3)(del * del)) << endl;
*/