load "msh3"
load "medit"

int nn = 16;
int Nt = 8;
int Nx = nn, Ny = nn;
int[int] labels = [1, 1, 1, 1];
mesh Th = square(Nx, Ny, label = labels);
fespace Vh(Th, P1);

mesh3 Th3 = cube(Nx, Ny, Nt);
fespace Vh3(Th3, P1);
Vh3 uu;
Vh3 ue = exp(z) * sin(pi * x) * sin(pi * y);
Vh3 fe = (1 + 2 * pi ^ 2) * ue;

real T = 1, dt = T / Nt;

Vh uprev = ue(x, y, 0);
Vh fprev = fe(x, y, 0);
Vh u, v;

for(int ny = 0; ny <= Ny; ny++){
	for(int nx = 0; nx <= Nx; nx++){
		uu[][ny * (Nx + 1) + nx] = uprev[][ny * (Nx + 1) + nx];
	}
}

macro grad(u) [dx(u), dy(u)]//

for(int nt = 1; nt <= Nt; nt++){

	Vh fnext = fe(x, y, nt * dt);
	
	solve CrankNicolson(u, v, solver = CG) = 
			int2d(Th)(u * v / dt + 0.5 * grad(u)' * grad(v))
			+ int2d(Th)(-uprev * v / dt + 0.5 * grad(uprev) '* grad(v))
			- int2d(Th)(0.5 * (fprev + fnext) * v)
			+on(1, u = 0);
			//- int1d(Th, 1, 2, 3, 4)((dx(uprev) * N.x + dy(uprev) * N.y) * v);

	for(int ny = 0; ny <= Ny; ny++){
		for(int nx = 0; nx <= Nx; nx++){
			uu[][nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = u[][ny * (Nx + 1) + nx];
		}
	}

	fprev = fnext;
	uprev = u;
}

cout << "Erorr in L2: " << sqrt(int3d(Th3)((uu - ue) ^ 2)) << endl; 