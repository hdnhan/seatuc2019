-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "ff-IpOpt"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\ff-IpOpt = 0)
    2 : load "msh3"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\msh3 = 0)
    3 : load "medit"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\medit = 0)
    4 :
    5 :
    6 : int nn = 40;
    7 : int Nx = nn, Ny = nn, Nt = nn;
    8 : real T = 1.0;
    9 : real hx = 1.0/Nx, hy = 1.0/Ny, ht = T/Nt;
   10 :
   11 : mesh Th2 = square(Nx, Ny);
   12 : fespace Vh2(Th2, P1);
   13 :
   14 : mesh3 Th3 = cube(Nx, Ny, Nt);
   15 : fespace Vh3(Th3, P1);
   16 :
   17 : macro grad(u) [dx(u), dy(u)] )   [dx(u), dy(u)]//
   18 :
   19 : // Data
   20 : Vh3 ue = exp(z) * sin(pi * x) * sin(pi * y);
   21 : Vh3 fe = sin(pi * z) * sin(pi * x) * sin(pi * y);
   22 : Vh3 q = x * y + z + 1;
   23 : Vh3 g = (1 + 2 * pi ^ 2) * ue - fe * q;
   24 : real gamma = 1e-5;
   25 :
   26 : Vh2 u0 = ue(x, y, 0);
   27 :
   28 : Vh3 w = ue;
   29 :
   30 : // State equation:
   31 : func real[int] StateProblem(real[int] f){
   32 :         Vh3 u3, f3; f3[] = f;
   33 :         Vh3 rhs = f3 * q + g;
   34 :     Vh2 u, v, fprev, fnext;
   35 :     Vh2 uprev = u0;
   36 :
   37 :     for(int ny = 0; ny <= Ny; ny++){
   38 :                 for(int nx = 0; nx <= Nx; nx++){
   39 :                         fprev[][ny * (Nx + 1) + nx] = rhs[][ny * (Nx + 1) + nx];
   40 :                         u3[][ny * (Nx + 1) + nx] = uprev[][ny * (Nx + 1) + nx];
   41 :                 }
   42 :         }
   43 :
   44 :     for(int nt = 1; nt <= Nt; nt++){
   45 :
   46 :                 for(int ny = 0; ny <= Ny; ny++){
   47 :                         for(int nx = 0; nx <= Nx; nx++){
   48 :                                 fnext[][ny * (Nx + 1) + nx] = rhs[][nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nous itrx];
   49 :                         }
   50 :                 }
   51 :
   52 :                 solve CrankNicolson(u, v, solver = CG) =
   53 :                           int2d(Th2)(u * v / ht + 0.5 * grad(u)   [dx(u), dy(u)]' * grad(v)   [dx(v), dy(v)])
   54 :                         + int2d(Th2)(-uprev * v / ht + 0.5 * grad(uprev)   [dx(uprev), dy(uprev)]' * grad(v)   [ous itrdx(v), dy(v)])
   55 :                         - int2d(Th2)(0.5 * (fprev + fnext) * v)
   56 :                         + on(1, 2, 3, 4, u = 0);
   57 :
   58 :                 for(int ny = 0; ny <= Ny; ny++){
   59 :                         for(int nx = 0; nx <= Nx; nx++){
   60 :                                 u3[][nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = u[][ny * (Nx + 1) + nx];
   61 :                         }
   62 :                 }
   63 :
   64 :                 fprev = fnext;
   65 :                 uprev = u;
   66 :         }
   67 :
   68 :         return u3[];
   69 : }
   70 :
   71 :
   72 :
   73 : // Adjoint equation
   74 : func real[int] AdjointProblem(real[int] u){
   75 :
   76 :     Vh3 p3;
   77 :     Vh3 rhs; rhs[] = u - w[];
   78 :
   79 :     Vh2 p, v, fprev, fnext;
   80 :     Vh2 pprev = 0;
   81 :     //Vh2 pprev = ue(x, y, T);
   82 :
   83 :     for(int ny = 0; ny <= Ny; ny++){
   84 :                 for(int nx = 0; nx <= Nx; nx++){
   85 :                         fprev[][ny * (Nx + 1) + nx] = rhs[][Nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx];
   86 :                         p3[][Nt * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = pprev[][ny * (Nx + 1) + nx];
   87 :                 }
   88 :         }
   89 :
   90 :     for(int nt = 1; nt <= Nt; nt++){
   91 :
   92 :                 for(int ny = 0; ny <= Ny; ny++){
   93 :                         for(int nx = 0; nx <= Nx; nx++){
   94 :                                 fnext[][ny * (Nx + 1) + nx] = rhs[][(Nt - nt) * (Nx + 1) * (Ny + 1) + ny * (Nx +ous itr 1) + nx];
   95 :                         }
   96 :                 }
   97 :
   98 :                 solve CrankNicolson(p, v, solver = CG) =
   99 :                           int2d(Th2)(p * v / ht + 0.5 * grad(p)   [dx(p), dy(p)]' * grad(v)   [dx(v), dy(v)])
  100 :                         + int2d(Th2)(-pprev * v / ht + 0.5 * grad(pprev)   [dx(pprev), dy(pprev)]' * grad(v)   [ous itrdx(v), dy(v)])
  101 :                         - int2d(Th2)(0.5 * (fprev + fnext) * v)
  102 :                         + on(1, 2, 3, 4, p = 0);
  103 :
  104 :                 for(int ny = 0; ny <= Ny; ny++){
  105 :                         for(int nx = 0; nx <= Nx; nx++){
  106 :                                 p3[][(Nt - nt) * (Nx + 1) * (Ny + 1) + ny * (Nx + 1) + nx] = p[][ny * (Nx + 1) +ous itr nx];
  107 :                         }
  108 :                 }
  109 :
  110 :                 fprev = fnext;
  111 :                 pprev = p;
  112 :         }
  113 :
  114 :         return p3[];
  115 : }
  116 :
  117 :
  118 : // Tikhonov functional
  119 : func real J(real[int] f) {
  120 :     Vh3 f3; f3[] = f;
  121 :     Vh3 u; u[] = StateProblem(f);
  122 :     Vh3 del; del[] = u[] - w[];
  123 :     return 0.5 * int3d(Th3)(del * del) + 0.5 * gamma * int3d(Th3)(f3 * f3);
  124 : }
  125 :
  126 :
  127 : // Gradient of Tikhonov funtional
  128 : func real[int] GradJ(real[int] f) {
  129 :     Vh3 p; p[] = AdjointProblem(StateProblem(f));
  130 :     Vh3 pq = p * q;
  131 :     real[int] res = pq[] + gamma * f;
  132 :     return res;
  133 : }
  134 :
  135 :
  136 :
  137 : Vh3 fh = 0;
  138 : //IPOPT(J, GradJ, fh[], tol = 1e-6);
  139 : IPOPT(J, GradJ, fh[]);
  140 : //savesol("2D_Q_fh.sol", Th, fh);
  141 :
  142 : cout << "J: " << J(fh[]) << endl;
  143 : Vh3 del = fh - fe;
  144 :
  145 : cout << "fe min and max: " << fe[].min << ", " << fe[].max << endl;
  146 : cout << "fh min and max: " << fh[].min << ", " << fh[].max << endl;
  147 : cout << "(fh-fe) min and max: " << del[].min << ", " << del[].max << endl;
  148 : cout << "erorr L2: " << sqrt(int3d(Th3)(del * del)) << endl;
  149 :
  150 :
  151 : /*
  152 : Vh3 haha = (-1 + 2 * pi ^ 2) * ue;
  153 : //Vh3 uap; uap[] = StateProblem(fe[]);
  154 : Vh3 del; del[] = AdjointProblem(haha[]) - ue[]; //uap - ue;
  155 : cout << "(fh-fe) min and max: " << del[].min << ", " << del[].max << endl;
  156 : cout << "erorr L2: " << sqrt(int3d(Th3)(del * del)) << endl;
  157 : */ sizestack + 1024 =10416  ( 9392 )
 
  -- Square mesh : nb vertices  =1681 ,  nb triangles = 3200 ,  nb boundary edges 160
  Enter: BuildCube: 6
    kind = 6 n tet Cube = 6 / n slip 6 70
  Cube  nv=68921 nt=384000 nbe=19200
  Out:  BuildCube
  -- FESpace: Nb of Nodes 68921 Nb of DoF 68921
 
IPOPT Note : No hessian given ==> LBFGS hessian approximation enabled
 
******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit http://projects.coin-or.org/Ipopt
******************************************************************************
 
This is Ipopt version 3.12.4, running with linear solver mumps.
NOTE: Other linear solvers might be more efficient (see Ipopt documentation).
 
Number of nonzeros in equality constraint Jacobian...:        0
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:        0
 
  -- Solve :
          min -1.31874e-035  max 1.0237
  -- Solve :
          min -1.34562e-035  max 1.04662
  -- Solve :
          min -1.3774e-035  max 1.06929
  -- Solve :
          min -1.40591e-035  max 1.09203
  -- Solve :
          min -1.43844e-035  max 1.11508
  -- Solve :
          min -1.46696e-035  max 1.13858
  -- Solve :
          min -1.50039e-035  max 1.16266
  -- Solve :
          min -1.53101e-035  max 1.1874
  -- Solve :
          min -1.56469e-035  max 1.2129
  -- Solve :
          min -1.59714e-035  max 1.23922
^C try getConsole D:\Study\HUST\FEM\Co Mai\seatuc2019\freefem++\Q.edp
